[{"content":"\r\r","description":"Application video for Microsoft Learn Student Ambassador","id":2,"section":"posts","tags":null,"title":"MLSA Application","uri":"https://rickenbacker620.github.io/posts/mlsa-application/"},{"content":"桶排序    平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性     O(n) O(n) O(m) 不稳定    桶排序简介 桶排序将数组分到有限数量的桶里，每个桶里再进行排序。由桶排序衍生出了基数排序和计数排序。\n桶排序适用场景 桶排序适用于元素值集合不多但是元素数量很多的情况。比如高考总分只有480分，但是考生远多于480，其中考生的分数肯定有重复的。那么只要创建480个桶，遍历每个考生把他放入对应的桶中就可以了。\n桶排序的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi) { int i = lo, j = hi; int k = rand() % (hi - lo + 1) + lo; //生成lo~hi之间的随机数k并用nums[i]作为基准数，防止快排退化  swap(nums[lo], nums[k]); //将这个数与lo处数据交换  while (i \u0026lt; j) { //j先开始移动，如果i先开始移动，最后i移动到j处时，ij重合处是比nums[k]大的。  //如果执意要先i开始移动，则选择数组的最后一位作为基准值nums[k]  while (i \u0026lt; j \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[lo]) j--; //从右开始遍历直到j处数据小于k  while (i \u0026lt; j \u0026amp;\u0026amp; nums[i] \u0026lt;= nums[lo]) i++; //从左开始遍历直到i处数据大于k  swap(nums[i], (i == j) ? nums[lo] : nums[j]); //i和j就位后交换i,j对应的数据，如果i与j重合，则将基准数与ij重合处交换  } return j; //返回划分点 } //对子数组进行排序 void qsubsort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi) { if (lo \u0026gt;= hi) //如果只剩下一个元素则返回  return; int pivot = partition(nums, lo, hi); //使用partition函数对数组进行切分，切分出一个pivot并返回  qsubsort(nums, lo, pivot-1); //对[lo, pivot-1]进行快排  qsubsort(nums, pivot+1, hi); //对[pivot+1, hi]进行快排 } //桶排序入口 void quicksort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int lo = 0, hi = nums.size()-1; qsubsort(nums, lo, hi); }    切分至数组长度较小时(例如小于10)可以使用插入排序提高效率\n ","description":"桶排序","id":3,"section":"posts","tags":["桶排序"],"title":"桶排序","uri":"https://rickenbacker620.github.io/posts/bucket-sorting/"},{"content":"   平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性     O(nlogn) O(n2) O(logn) 不稳定    快速排序简介 快速排序又称分区交换排序，是一种非常常用的排序方法。通常情况下比其他算法更快，因为它的内部循环可以在大部分架构上很有效率地达成。\n快速排序适用场景 快速排序在处理链表上不如稳定的归并排序。快速排序一般和堆排序进行比较，堆排序比快速排序稍慢，但快速排序的最坏时间复杂度比堆排序高，且额外空间复杂度比堆排序高。\n对于int,double这种简单数据类型，用快速排序是很好的，但对于一些复杂类型，快速排序就不如归并排序或折半插入排序了。这是因为对于复杂数据类型来说，移动的成本远低于比较的成本。\n快速排序的实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi) { int i = lo, j = hi; int t = rand() % (hi - lo + 1) + lo; //生成lo~hi之间的随机数k并用nums[i]作为基准数，防止快排退化，也可以使用中位数  swap(nums[lo], nums[t]); //将这个数与lo处数据交换  while (i \u0026lt; j) { //j先开始移动，如果i先开始移动，最后i移动到j处时，ij重合处是比nums[k]大的。  //如果执意要先i开始移动，则选择数组的最后一位作为基准值nums[k]  while (i \u0026lt; j \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[lo]) j--; //从右开始遍历直到j处数据小于k  while (i \u0026lt; j \u0026amp;\u0026amp; nums[i] \u0026lt;= nums[lo]) i++; //从左开始遍历直到i处数据大于k  swap(nums[i], nums[j]); //i和j就位后交换i,j对应的数据  } swap(nums[i], nums[lo]); //如果i与j重合，则将基准数与ij重合处交换  return i; //返回划分点 } //对子数组进行排序 void qsubsort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi) { if (lo \u0026gt;= hi) //如果只剩下一个元素则返回  return; int pivot = partition(nums, lo, hi); //使用partition函数对数组进行切分，切分出一个pivot并返回  qsubsort(nums, lo, pivot-1); //对[lo, pivot-1]进行快排  qsubsort(nums, pivot+1, hi); //对[pivot+1, hi]进行快排 } //快速排序入口 void quicksort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int lo = 0, hi = nums.size()-1; qsubsort(nums, lo, hi); }    上面的快速排序对于重复元素较多的数据退化很严重，比如一组一模一样的数据会使上述排序退化为冒泡排序。因为每次切分时，j指针会直接移到i指针处并返回i为pivot。设数组有n个相同元素，这样切分出来的数组是一个n-1个元素的数组，和一个pivot，并继续在n-1个元素的数组中进行排序。\n 三向切分的快速排序 为了解决大量重复元素的问题，三向切分将数组切分为小于区，等于区，大于区。\n子数组切分时，只要从小于、大于区切分，等于区不用管。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  //对子数组进行排序 void qsubsort3way(vector\u0026lt;int\u0026gt;\u0026amp; nums, int lo, int hi) { if (lo \u0026gt;= hi) //如果只剩下一个元素则返回  return; int i = lo, j = lo + 1, k = hi; int t = rand() % (hi - lo + 1) + lo; //生成lo~hi之间的随机数k并用nums[i]作为基准数，防止快排退化  swap(nums[t], nums[lo]); int cmp = nums[lo]; //和普通的快排不同，这里要记录下基准数  while (j \u0026lt;= k) { if (nums[j] \u0026lt; cmp) //如果j小于基准数，则与i交换  swap(nums[i++], nums[j++]); //交换后i,j各向右一步  else if (nums[j] \u0026gt; cmp) //如果j大于基准数，则与k交换  swap(nums[k--], nums[j]); //交换后k向左一步  //这里i需要跟随j移动但k不需要，是因为j走过的路程上大的元素给k，小的元素给i，已经分好了。//而i走过的路程j必定走过一遍，所以不可能遇到比cmp更大的数了，所以直接前进。  //k走过的路上的数据对于j是未知的，所以从k发送给j的数据j需要再次判断。  else j++; //否则j向右一步  } qsubsort3way(nums, lo, i-1); //对[lo, i-1]进行快排  qsubsort3way(nums, k+1, hi); //对[k+1, hi]进行快排 } //快速排序入口 void quicksort3way(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int lo = 0, hi = nums.size()-1; qsubsort3way(nums, lo, hi); }   Your browser does not support the video tag.\r\r 切分至数组长度较小时(例如小于10)可以使用插入排序提高效率\n ","description":"快速排序","id":4,"section":"posts","tags":["快速排序"],"title":"快速排序","uri":"https://rickenbacker620.github.io/posts/quick-sorting/"},{"content":"   平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性     O(nlog2n) O(nlog2n) O(n) 稳定    归并排序简介 归并排序把一组数据分为两段，将两段数据排序，再从两段中逐个选中最小的元素放入新数据段的末尾。该算法是分治法一个非常典型的应用，并且各层分治递归可以同时进行。这种过程类似于打扑克牌，从最小的牌开始出，并且两人都要比对手的牌大，这个过程就是归并，一轮出牌后你会发现牌桌上的牌是从小到大依次排好的。\n归并排序适用场景 归并排序适合大数组，归并排序求逆序对非常方便，只需要在j指针指向的数值比i指针大时记录即可。但是递归排序需要开一般需要开一个与原数组等大的临时数组，当然，经过优化也可以使空间复杂度达到o(1)，这种归并排序类似于快速排序。\n归并排序的递归实现(Top-down) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  //将temp中的数归并到nums void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; temp, int lo, int mid, int hi) { if (temp[mid] \u0026lt;= temp[mid+1]) //如果temp[mid]\u0026lt;=temp[mid+1]则表示两个有序数组直接合并后就已经有序  { for (int k = lo; k \u0026lt;= hi; k++) //直接把数组从temp传回nums  nums[k] = temp[k]; return; } int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) //从temp中取元素往nums中填充，直到第hi位  if (i \u0026gt; mid) //如果i中数据已经填充完  nums[k] = temp[j++]; //剩下的用j中数据填充  else if (j \u0026gt; hi) //如果j中数据已经填充完  nums[k] = temp[i++]; //剩下的用i中数据填充  else if (temp[i] \u0026lt;= temp[j]) //如果i比j小或i=j  nums[k] = temp[i++]; //则先填充i(i=j时填充i可以保证排序的稳定性)  else if (temp[j] \u0026lt; temp[i]) //如果j比i小  nums[k] = temp[j++]; //则先填充j } //将传入的nums排序 void msubsort(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; temp, int lo, int hi) { if(lo \u0026gt;= hi) //如果只剩一个元素则返回，此处还可以改为如果数组规模小于10则改插入排序  return; int mid = lo + (hi - lo)/2; //将数组对半切分  msubsort(temp, nums, lo, mid); //分别对每一半数组进行排序，此处将temp和nums交换传入，可以来回赋值提高效率  msubsort(temp, nums, mid+1, hi); //假设递归过程中其中一层是由nums归并到temp，那么下一层就用temp归并到nums  merge(nums, temp, lo, mid, hi); //再对两个有序数组进行归并 } //归并排序的入口，最顶层的，也是最后一次归并 void mergesort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; temp = nums; //首先一次性声明一个长度为排序数组长度的临时数组  sort(nums, temp, 0, nums.size()-1); //进行对这个数组进行归并排序 }   归并排序的迭代实现(Bottom-up) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  //此处代码与递归版本略有不同，迭代版本先将待归并的数据存入temp后归并回nums，而非交替归并(其实是可以优化的) void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;int\u0026gt;\u0026amp; temp, int lo, int mid, int hi) { int i = lo, j = mid + 1; for (int k = lo; k \u0026lt;= hi; k++) //先从nums中把待归并的数存入temp  temp[k] = nums[k]; for (int k = lo; k \u0026lt;= hi; k++) //从temp中取元素往nums中填充，直到第hi位  if (i \u0026gt; mid) //如果i中数据已经填充完  nums[k] = temp[j++]; //剩下的用j中数据填充  else if (j \u0026gt; hi) //如果j中数据已经填充完  nums[k] = temp[i++]; //剩下的用i中数据填充  else if (temp[i] \u0026lt;= temp[j]) //如果i比j小或i=j  nums[k] = temp[i++]; //则先填充i(i=j时填充i可以保证排序的稳定性)  else if (temp[j] \u0026lt; temp[i]){ //如果j比i小  nums[k] = temp[j++]; //则先填充j  } } void mergesort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); vector\u0026lt;int\u0026gt; temp(len); for (int size = 1; size \u0026lt; len; size *= 2) //定义size为子数组长度，从1开始，直到2*size\u0026gt;len为止  for (int lo = 0; lo \u0026lt; len-size; lo += 2*size) //lo为每次merge的起点，每次merge两个大小为size的子数组，故lo每次增加两个size  mergev(nums, temp, lo, lo+size-1, min(lo+2*size-1, len-1)); //同递归版本的merge一样，其中lo依然为lo, mid为lo+size-1, hi为lo+2*size-1。  //即merge[low, lo+size-1]和[lo+size, lo+2*size-1]这两个数组  //但是如果merge时，由lo+2*size得出的hi已经溢出，则merge[low, lo+size-1]和[lo+size, len-1]这两个数组 }    切分至数组长度较小时(例如小于15)可以使用插入排序提高效率\n ","description":"归并排序","id":5,"section":"posts","tags":["归并排序"],"title":"归并排序","uri":"https://rickenbacker620.github.io/posts/merge-sorting/"},{"content":"冒泡排序    平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性     O(n2) O(n2) O(1) 稳定    冒泡排序简介 冒牌排序易于理解，稳定，且冒泡排序还是一种就地排序。（即不需要新开空间） 其实就是并没有什么卵用的意思\n冒泡排序适用场景 由于冒泡排序较为通俗易懂，所以大多数教材所介绍的第一个排序方法为冒泡排序。 早期存储设备容量不够所以在磁带上完成就地排序时会使用冒泡。\n冒泡排序写法 1 2 3 4 5 6 7 8 9 10 11 12  void bubble(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = a.size(); for (int i = 0; i \u0026lt; len-1; i++) //外循环从0开始仅用于记录循环次数，次数为i  { for (int j = 0; j \u0026lt; len-i-1; j++) //内循环，第i次循环时，第i个元素已经上浮至顶端，所以只需执行(len-i)-1次  { if (nums[j] \u0026gt; nums[j+1]) //如果顺序不符合规则则交换  swap(nums[j], nums[j+1]); } } }   选择排序    平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性     O(n2) O(n2) O(1) 数组不稳定，链表稳定    选择排序简介 顾名思义，选择排序就是遍历数组中所有元素，按从小到大的顺序选出，再依次将所选出的数放入合适的位置。\n选择排序适用场景 选择排序运行时间与输入无关，并且移动数据是最少的 （即很少交换两数位置，swap函数仅使用了len-1次）。选择排序实现也比较简单，并且由于在各种情况下复杂度波动小，因此一般是优于冒泡排序的。在所有的完全交换排序中，选择排序也是比较不错的一种算法。但是，由于固有的O(n2)复杂度，选择排序在海量数据面前显得力不从心。因此，它适用于简单数据排序。\n选择排序写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void selection(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int count = 0; int len = nums.size(); for (int i = 0; i \u0026lt; len-1; i++) //外循环i代表当前索引，当i=len-2时，前len-1个元素已经就位，故最后一个元素不需要处理  { int min = i; //假设第i个元素应当放在nums[i]位  for (int j = i+1; j \u0026lt; len; j++) //内循环从i+1开始依次与min比较  { if (nums[min] \u0026gt; nums[j]) //若nums[j]比nums[min]还小则把j取为min  min = j; } swap(nums[i], nums[min]); //比较完最后一位后将此轮的nums[min]放入nums[i]  } }   插入排序    平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性     O(n2) O(n2) O(1) 稳定    插入排序简介 插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入，类似于打扑克牌时整理牌面的手法。插入排序在实现上，通常采用就地排序，因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n插入排序适用场景 插入排序比起选择和冒泡较为常用，适用于处理小规模的数据。在快速排序将大数组划分为较小的数组时改为插入排序可以提高效率。在 STL 的 sort 算法和 stdlib 的 qsort 算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。\n插入排序写法 1 2 3 4 5 6 7 8 9 10 11 12  void insertion(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); int j, key; for (int i = 1; i \u0026lt; len; i++) //外循环从1开始，假设i之前的数组时有序的  { //内循环将nums[i]插入到num[i-1]、nums[i-2]...之间  key = nums[i]; //先记录下当前循环所要插入的数字  for (j = i; j \u0026gt; 0 \u0026amp;\u0026amp; nums[j-1] \u0026gt; key; j--) nums[j] = nums[j-1]; //从选定的位置开始向前遍历，若不符合排序要求则将nums[j-1]向后挪一位  nums[j] = key; //记录下最后的插入位置并将nums[i]插入  } }    关于选择排序和插入排序:\n选择排序比较次数多，交换次数少，插入排序比较次数少，交换次数多。请务必灵活选择。\n  在复杂排序算法处理到一定程度时可以嵌入插入排序\n 1 2 3 4 5  if (hi - lo \u0026lt; 10) { insertion(nums, lo, hi) return; }   希尔排序    平均时间复杂度 最坏时间复杂度 额外空间复杂度 稳定性     O(nlog2n) O(n2) O(1) 不稳定    希尔排序简介 希尔排序是一种基于插入排序的快速的排序方法。插入排序对于大规模乱序数组很慢，因为它只能交换相邻的元素。例如，如果值最小的元素在数组尽头，那它将一步一步移动整个数组的长度到达0位置处。希尔排序使数组中任意间隔为h的元素都是有序的。所以希尔排序把一个数组分为几个子数组先进行排序，也算是一种分治思想。\n希尔排序适用场景 对于中等大小的程序，希尔排序的运行时间是可以接受的。它的代码量很小，且不需要使用额外的内存空间。对于直接接触硬件的低级语言，希尔排序简单且高效，优于直接插入排序，但是不稳定。\n希尔排序写法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  void shell(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); int h = 1; while (h \u0026lt; len/3) h = 3*h + 1; //先让h按照h=3*h+1这个递增公式增加到不超过数组长度1/3的最大值  while (h \u0026gt;= 1) //h有序数组不断缩小直至1，循环内部是直接插入排序，仅仅是把1换成x，最后一次循环h=1，就是直接插入排序  { int j, key; for (int i = h; i \u0026lt; len; i++) { key = nums[i]; for (j = i; j \u0026gt; h \u0026amp;\u0026amp; nums[j-h] \u0026gt; key; j-=h) nums[j] = nums[j-h]; nums[j] = key; } h = h/3; //h数组每次减少至原来的1/3  } }    上面的希尔排序的递增序列是最常用最好写的，但并不是效率最高的。这里有一组效率更高的递增序列，但是需要开数组存放。相较于原来的h=h/3可以提升10%~20%的效率。\n  {1, 5, 19, 41, 109, 209, 505, 929, 2161, 3905, 8928, 16001, 36289, 64796, 146305}\n ","description":"冒泡排序,选择排序,插入排序","id":6,"section":"posts","tags":["冒泡排序","选择排序","插入排序"],"title":"初级排序算法","uri":"https://rickenbacker620.github.io/posts/basic-sorting/"},{"content":"C++不像Java一样有非常好用的timer来进行测试，测试某些算法的性能非常不方便，所以需要自己写一个timer。\n首先需要用到C++中的chrono库，里面有一些非常好用的工具。\nduration duration 指的是一段时间，是类模板, duration 的全名是 std::chrono::duration\nduration 的使用方法是 duration\u0026lt;class Rep, class Period\u0026gt;\nRep 指表现形式，如int, float, double\u0026hellip;\nPeriod 指时间单位，如nano(ratio\u0026lt;1,1000000000\u0026gt;), micro(ratio\u0026lt;1,1000000\u0026gt;), milli(ratio\u0026lt;1,1000\u0026gt;)\n如果想要表示小时则写成ratio\u0026lt;3600\u0026gt;, 分钟ratio\u0026lt;60\u0026gt;, 秒ratio\u0026lt;1\u0026gt;\n在头文件chrono中已经定义了这些常见时间单位，可以直接使用\n1 2 3 4 5 6  using nanoseconds = duration\u0026lt;long long, nano\u0026gt;; using microseconds = duration\u0026lt;long long, micro\u0026gt;; using milliseconds = duration\u0026lt;long long, milli\u0026gt;; using seconds = duration\u0026lt;long long\u0026gt;; using minutes = duration\u0026lt;int, ratio\u0026lt;60\u0026gt;\u0026gt;; using hours = duration\u0026lt;int, ratio\u0026lt;3600\u0026gt;\u0026gt;;   duration_cast seconds x = 3200ms 这样的操作是不允许的，因为会丢失精度，所以要用到duration_cast\nseconds x = duration_cast\u0026lt;seconds\u0026gt;(3200ms) 就可以了\nseconds x = duration_cast\u0026lt;long long, ratio\u0026lt;1\u0026gt;\u0026gt;(3200ms) 也是一样的效果\ntime_point time_point 也是类模板，指某个时间点，time_point 相减可以得到一个 duration\ntime_point 和 duration 类似，也有 time_point_cast ，用法也类似\ntime_point.time_since_epoch(), 可以将 time_point 转化为从 epoch 到当前 tp 的 duration\nclock clock 分为三类，system_clock， steady_clock， high_resolution_clock\n一般不使用 high_resolution_clock ，因为它有可能是 system_clock 和 steady_clock 其中之一\nsystem_clock不稳定，一般在想要获得当前系统时间时使用\nsteady_clock一般作为定时器计算 duration 使用\n最常用的是clock::now()来获取当前时间\npractice 这是一个Timer类，可以和函数放入同一个scope达到同时构造同时销毁的效果\n测试算法时非常方便\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Timer { public: Timer() { start = high_resolution_clock::now(); cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; } ~Timer() { auto end = high_resolution_clock::now(); auto duration = std::chrono::duration\u0026lt;double\u0026gt;(end - start); cout \u0026lt;\u0026lt; \u0026#34;Time passed:\u0026#34; \u0026lt;\u0026lt; duration.count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;--------------------\u0026#34; \u0026lt;\u0026lt; endl; } private: std::chrono::time_point\u0026lt;std::chrono::high_resolution_clock\u0026gt; start; };   ","description":"如何测试C++程序的运行效率","id":7,"section":"posts","tags":["benchmark"],"title":"C++ Benchmark","uri":"https://rickenbacker620.github.io/posts/cppbenchmark/"},{"content":"排序算法  所有的排序算法中一般都包含几个固定的函数:\n    函数 功能     compare(less/more)函数(C++中使用重载运算符 \u0026lt;/\u0026gt; 实现) 比较数据大小   swap函数 交换两数   show函数 打印排序后的数据   check函数 检查该组数据是否已经成功排序    compare函数    变量 含义     cmp 用于比较的参数   lhs 左侧的参数   rhs cmp即右侧的参数    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  bool Compareclass::operator\u0026gt;(Compareclass\u0026amp; cmp) { //when lhs \u0026gt; rhs  if (/*code*/) return true; else return false; } bool Compareclass::operator\u0026lt;(Compareclass\u0026amp; cmp) { //when lhs \u0026lt; rhs  if (/*code*/) return true; else return false; } bool Compareclass::operator==(Compareclass\u0026amp; cmp) { //when lhs = rhs  if (/*code*/) return true; else return false; } bool Compareclass::operator\u0026lt;=(Compareclass\u0026amp; cmp) { //when lhs \u0026gt; rhs  if (/*code*/) return false; else return true; } bool Compareclass::operator\u0026gt;=(Compareclass\u0026amp; cmp) { //when lhs \u0026lt; rhs  if (/*code*/) return false; else return true; }   swap函数 1 2 3 4 5 6 7  void swap(Compareclass\u0026amp; swp1, Compareclass\u0026amp; swp2) { Compareclass temp; temp = swp1; swp1 = swp2; swp2 = temp; }   show函数 1 2 3 4 5 6 7  void show(Compareclass* shw) { for (int i = 0; i \u0026lt; shw.length(); i++) { cout \u0026lt;\u0026lt; shw[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } }   check函数 1 2 3 4 5 6 7 8 9  bool check(Compareclass* chk) { for (int i = 1; i \u0026lt; chk.length(); i++) { if(/*chk[i],chk[i-1] compared*/) return false; } return true; }   ","description":"排序算法的一些常见api","id":8,"section":"posts","tags":["排序"],"title":"排序算法概述","uri":"https://rickenbacker620.github.io/posts/sortlead/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":12,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://rickenbacker620.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":13,"section":"gallery","tags":null,"title":"Photo","uri":"https://rickenbacker620.github.io/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n","description":"Hugo, the world’s fastest framework for building websites","id":14,"section":"","tags":null,"title":"About","uri":"https://rickenbacker620.github.io/about/"}]